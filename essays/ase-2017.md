---
layout: essay
type: essay
published: false
title: Athletic Software Engineering (2017)
date: 2017-05-30
labels:
  - Athletic Software Engineering
---

For the past four years, I have been refining a pedagogy called "Athletic Software Engineering Education".   This essay presents the motivation for the pedagogy, a brief introduction to how I currently teach it, and the results of student evaluations of the method and my class.

### Motivation

The motivation for athletic software engineering arises from my goals for the students in my course:

  1. *To acquire competency with a minimal technology stack for modern software application development.* In the case of my class, this "minimal" stack includes Javascript, git, GitHub, ESLint, IntelliJ, HTML, CSS, Semantic UI, markdown, mocha, chai, npm, Meteor, MongoDB, and Galaxy.
    
  2. *To confront and solve "design" problems.* Design problems occur at the code level (for example, how to structure code so that it is testable), as well as at the user interface level (for example, how to organize the presentation and manipulation of data so that user needs are satisfied).
  
  3. *To confront and solve "process" problems.* Process problems involve group communication and coordination, and how to define, delegate, and manage tasks such that a group of developers can work together to create a functional application in a limited amount of time. 
  
  4. *Invent an application that solves a "real world" problem for UH students.* For example, students on a meal plan get a certain number of "points" each week for buying food, which do not roll over if unused. To solve this inefficiency, one of my student teams developed an app called "Manoa Dining Delivery", in which students can turn their expiring points into cash by purchasing food at the cafeteria and delivering it to another student on campus. Here is their home page:

<img class="ui responsive image" src="{{ site.baseurl }}/images/manoa_dining_landing.jpg">

These goals build on each other: without competency with a technology stack, it is difficult to successfully address significant coding and user interface design problems.  Significant design problems are needed in order to provide a context for team work with significant process problems. And without the ability to confront and address both design and process problems, it is difficult to create solutions to real world problems (at least within the boundaries of a single semester.)

Furthermore, developing an application to solve a "real world problem" that provides opportunities to experience significant design and process problems is not something that can be done overnight.  I find that students need a minimum of six weeks for the final project in order to achieve something they can be proud of, which leaves only 10 weeks to develop "competency" with the underlying tools and techniques. I developed Athletic Software Engineering to solve the pedagogical problem of developing competency with a significant set of tools and technologies within the context of an undergraduate course. 

### Why "competency" is important

Consider the following development scenario, which is typical during final project development:
 
*A student chooses a development task (Issue 23) from the GitHub Project board, and moves it from "Backlog" to "In Progress". She then creates and publishes a new git branch called "Issue-23" off the project's master branch in which to accomplish the task. The task involves the creation of a new page containing a form in the application. She creates a new page template in Meteor along with a route to that page, several Javascript callback functions to manage form processing, and a responsive layout for the page using HTML, CSS, and Semantic UI. To store the results from the form, she extends a MongoDB collection with new fields, and writes a test using mocha and chai. In the IntelliJ IDEA editor, she notes any ESLint code style errors as they occur and removes them. When the page works correctly, she commits her branch to GitHub, merges the results into the master branch, and moves the task from "In Progress" to "Done".*

Notice that in this (very simple!) development scenario, there are explicit references to a dozen components of a technology stack (GitHub, git, Meteor, Javascript callbacks, HTML, CSS, Semantic UI, MongoDB, mocha, chai, IntelliJ, and ESLint).  There are also implicit references to design problems (What information is being manipulated on that page? Is that the right information to manipulate? Is the chosen page the appropriate place to manipulate that information?) and process problems (Is that the appropriate task for that developer to work on right now? How might that task interact with others being worked on by others in the group? What communication should be occurring to make sure the developers do not implement conflicting code?)

Here is the key insight motivating athletic software engineering: if a student is competent with the technology stack, then _and only then_ is it possible for that student to actively engage with the "design" and "process" issues in development. If a student is not competent with one or more elements of the technology stack, then the focus of attention devolves to obtaining competency. For example, if a student does not understand how to implement a form in Meteor using Semantic UI, then that will be her sole focus of attention until she is competent with that skill; she will not be able to engage with "design" issues around forms when she can't even implement one.  By analogy, consider a guitarist who cannot tune his instrument.  Until he is competent with this skill, he has little hope of progress with chords, inversions, and harmony.
 
One natural question is whether I am introducing an overly complex technology stack.  In fact, I strive to introduce as minimal a technology stack as possible, such that whatever complexity results is intrinsic to the practice of software engineering. Consider that the 12 tools can be organized into the following categories, which I view as fairly central concepts in elementary software engineering:
 
  1. Programming Language (Javascript)
  2. Development Environment (Intellij IDEA)
  3. Project Management (GitHub issues and project boards)
  4. Configuration Management (git branch and merge)
  5. User Interface (HTML, CSS, Semantic UI)
  6. Testing and quality assurance (mocha, chai, ESLint)
  7. Database-backed application framework (Meteor, MongoDB)
  
Over the years, I have taught the class with many different combinations of technologies (Java rather than Javascript, Play rather than Meteor, Bootstrap rather than Semantic UI, Subversion rather than git, Google Project Hosting rather than GitHub, JUnit rather than mocha/chai), but the seven essential software engineering concepts persist, as well as the need to obtain competency with it in order to experience "design" and "process" problems.

### Efficient and effective development of competency

Athletic software engineering is a term I created to describe a set of interrelated teaching practices whose goal is to help students develop "competency" with basic software engineering skills prior to their final project. If they achieve competency with most or all of the skills, then the final project enables them to develop experience with solving design and process problems, and also makes it more likely that they will successfully implement a "minimum viable product".  
 
While a description of athletic software engineering sufficient for classroom implementation is beyond the scope of this essay, here are some of the key features that distinguish it from other approaches.

*Weekly modules.*  The class is organized into a sequence of "modules", each lasting one week. When my class meets on Tuesdays and Thursdays, then each module begins on Friday and lasts until the end of class on the following Thursday.  Students work on "practice WODs" from Friday to Monday, then do a "group WOD" on Tuesday, and do an "in class" WOD on Thursday to complete the module.

*Skill acquisition, not concept acquisition.* Students are evaluated based upon their ability to complete a task, not on their ability to discuss a concept. For example, a test module would evaluate the ability of a student to define and implement a unit test, not evaluate the ability of the student to describe the difference between a black box test and a white box test. 

*Workout of the day (WOD).*  I have adapted the CrossFit "WOD" to Athletic Software Engineering. In ASE, a "WOD" is a problem that requires the student to exercise one or more skills both correctly (i.e. such that the problem is solved) and efficiently (i.e. within a time limit). There is an upper bound on the time allowed to solve a problem (which typically makes it impossible to "google your way to the answer".) My heuristic is to time myself solving the problem, then double that elapsed time to establish the upper bound on how long students have to solve the problem.  This upper bound is referred to as the "DNF" time (or "Did Not Finish"). This past year, I assigned around 35 WODs each semester, which ranged from 5 minutes to 40 minutes to complete, with most WODs having a DNF time of somewhere between 10 and 20 minutes.

*Practice WODs.*  Each module provides several "practice WODs" to be done as homework between Friday and Tuesday. Practice WODs differ from traditional homework assignments in several ways. First, each practice WOD indicates, in addition to the problem to be solved, the time limit for successful completion of the WOD.  Second, each practice WOD includes a video of me solving the problem, and timing myself while doing so. Third, I typically instruct students to first attempt to solve the problem by themselves without watching my solution video, and time themselves while they do so. If they have not solved the problem by the DNF time, then they should stop at that point and watch my solution video, then try to solve the problem again from scratch, timing their second attempt as well.  If they cannot complete the assignment before the DNF time again, they should review the video and keep attempting to solve the problem until they can do it within the specified time interval. 

Some students admit that they do not follow this procedure, although most learn quickly that this is actually the most efficient way to acquire competency and avoid the dreaded DNF on the "in class WOD" (see below).

*Group WODs.* The Tuesday class is dedicated to one or more "Group WODs".  For each Group WOD, I randomly split the class into groups of two. I then provide a new problem for them to solve using the same skills they (hopefully) developed from the practice WODs.  However, they are now working in a group, and they have to work concurrently (in most cases, I ask that they both complete typing each line of code before either can type the next one.)  Once again, there is a time limit, although the limit is elevated since working concurrently can slow things down, and because I want to encourage them to discuss issues as they arise during the solution process.
 
The Group WOD fulfills several pedagogical goals. First, it provides a self-assessment procedure for students; they can see if their work on the practice WOD has actually prepared them to successfully solve a new problem. Second, it provides an engaging classroom learning environment; rather than working silently alone, they get to work with another student. By the end of the semester, most students have had 1-on-1 time with most other students in the class. Third, it incentivizes students to do the practice WODs, since they know that they will need to demonstrate the skill in class in Tuesday with another student, and this creates social pressure to prepare.  Finally, doing the Group WOD helps the students acquire more competency with the skill itself. 

*In class WOD.* 



  * The course consists of a sequence of one week modules.
  
  * Each module is designed to teach a set of skills.  Modules typically build on each other, so that developing competency with this week's skills requires competency with prior week's skills.  Note that sometimes the "lightbulb turns on" for a student after multiple weeks, such that they are suddenly acquire competency with several skills all at once.
  
  * For AY 2016-17, the modules included: Basic Javascript, Object oriented Javascript, Functional Javascript, GitHub and Git, IntelliJ IDEA, ESLint, HTML/CSS, Semantic UI, Meteor (a sequence of four modules), Project Management using GitHub issues and project boards.     
  
  * If the class meets on Tuesdays and Thursdays, then each module starts on Friday and ends at the end of the following Thursday class.
  
  * Between each Friday and Tuesday, the students are responsible for attempting to learn the skills associated with the module.  They do this through assigned readings or videos, as well as through a set of "practice workouts".  A "practice workout" (also called a practice WOD following CrossFit terminology) is a problem that must be solved by utilizing the skills associated with the module. 
   
  * Any "lectures" occur through online videos that the students watch between Friday and Tuesday.  All class time is devoted to actual practice with skills. 
   
  * Most videos are not lectures, however. Instead, for each module, there are typically videos showing the instructor demonstrating how to solve 
  












  




 











   
 
