---
layout: essay
type: essay
published: true
title: Athletic Software Engineering (2017)
date: 2017-05-30
labels:
  - Athletic Software Engineering
---

For the past four years, I have been practicing a pedagogy called "Athletic Software Engineering".   This essay presents the motivation for the pedagogy, a brief introduction to how I currently teach it, and the results of student evaluations of the method and my class.

## Motivation

To motivate athletic software engineering, you need to first understand the goals of my software engineering course:

  1. *Acquire competency with a minimal technology stack for modern software application development.* In the case of my class, this "minimal" stack includes Javascript, git, GitHub, ESLint, IntelliJ, HTML, CSS, Semantic UI, markdown, mocha, chai, npm, Meteor, MongoDB, and Galaxy.
    
  2. *Experience "design" problems.* Design problems occur at the code level (for example, how to structure code so that it is testable), as well as at the user interface level (for example, how to organize the presentation and manipulation of data so that user needs are satisfied).
  
  3. *Experience "process" problems.* Process problems involve group communication and coordination, and how to define, delegate, and manage tasks such that a group of developers can work together to create a functional application in a limited amount of time. 
  
  4. *Design and implement an application that solves a "real world" problem for UH students.* For example, students on a meal plan get a certain number of "points" each week for buying food, which do not roll over if unused. To solve this inefficiency, one team developed an app called "Manoa Dining Delivery", in which students can turn their expiring points into cash by purchasing food at the cafeteria and delivering it to another student on campus. Here is a portion of their home page:

<img class="ui bordered responsive image" src="{{ site.baseurl }}/images/manoa_dining_landing.jpg">

These four goals build on each other: without competency with a technology stack, it is difficult to experience significant coding and user interface design problems.  Significant design problems are needed in order to provide a context for teams to experience process problems. And without the ability to solve both design and process problems, it is difficult to design and implement a "real world" application.

It is important to note that developing an application to solve a "real world problem" is not something that students can accomplish overnight.  I find they need a minimum of six weeks of the semester to focus on the final project, which leaves only 10 weeks to develop "competency" with the underlying tools and techniques. I developed Athletic Software Engineering to solve the pedagogical problem of developing competency with a significant set of tools and technologies in the short period of time available during a semester. 

## Why "competency" is important

Consider the following development scenario, which is typical during final project development:
 
*A student chooses a development task (Issue 23) from the GitHub Project board, and moves it from "Backlog" to "In Progress". She then creates and publishes a new git branch called "Issue-23" off the project's master branch in which to accomplish the task. The task involves the creation of a new page containing a form in the application. She creates a new page template in Meteor along with a route to that page, several Javascript callback functions to manage form processing, and a responsive layout for the page using HTML, CSS, and Semantic UI. To store the results from the form, she extends a MongoDB collection with new fields, and writes a test using mocha and chai. In the IntelliJ IDEA editor, she notes any ESLint code style errors as they occur and removes them. When the page works correctly, she commits her branch to GitHub, merges the results into the master branch, and moves the task from "In Progress" to "Done".*

Notice that in this (very simple) development scenario, there are nevertheless explicit references to a dozen technologies (GitHub, git, Meteor, Javascript callbacks, HTML, CSS, Semantic UI, MongoDB, mocha, chai, IntelliJ, and ESLint).  There are also implicit references to design problems (What information is being manipulated on that page? Is that the right information to manipulate? Is the chosen page the appropriate place to manipulate that information?) and process problems (Is that the appropriate task for that developer to work on right now? How might that task interact with others being worked on by others in the group? What communication should be occurring to make sure the developers do not implement conflicting code?)

One key insight motivating athletic software engineering is this: if a student is competent with the technology stack, then _and only then_ is it possible for that student to actively engage with "design" and "process" problems. If a student is not competent with the technology stack, then their focus devolves to the technology stack, not "design" or "process". For example, if a student does not understand how to implement a form in Semantic UI, then that becomes her focus of attention; it is impractical for her to compare and contrast design alternatives when she does not know how to implement any of them.  By analogy, consider a guitarist who cannot tune his instrument.  Until he is competent with this skill, he has little hope of progress with chords, inversions, and harmony.

## The intrinsic complexity of a software engineering technology stack
 
One interesting question is whether my course requires an overly complex technology stack.  In reality, I strive to require as minimal a technology stack as possible, such that whatever complexity results is intrinsic to the practice of software engineering. Consider that the 12 technologies in my class can be organized into the following categories, which I view as fairly central concepts in elementary software engineering:
 
  1. Programming Language (Javascript)
  2. Development Environment (Intellij IDEA)
  3. Project Management (GitHub issues and project boards)
  4. Configuration Management (git branch and merge)
  5. User Interface (HTML, CSS, Semantic UI)
  6. Testing and quality assurance (mocha, chai, ESLint)
  7. Application framework (Meteor, MongoDB)
  
Over the years, I have taught the class with many different combinations of technologies (Java rather than Javascript, Play rather than Meteor, Bootstrap rather than Semantic UI, Subversion rather than git, Google Project Hosting rather than GitHub, JUnit rather than mocha/chai), but these seven essential software engineering technology classes persist, as well as the need to obtain competency with them in order to experience "design" and "process" problems.

## Efficient and effective development of competency

Athletic software engineering is a term I created to describe a set of interrelated teaching practices whose goal is to help students develop "competency" with basic software engineering skills prior to commencing their final project. If they achieve competency with most or all of the skills, then the final project enables them to develop experience solving design and process problems, makes it more likely that they will successfully implement a "minimum viable product", and results in a significantly richer educational outcome.  
 
While a description of athletic software engineering sufficient for classroom implementation is beyond the scope of this essay, here are some key features that distinguish it from other approaches.

**Weekly module schedule.**  The class is organized into a sequence of "modules", each lasting one week. If my class meets on Tuesdays and Thursdays, then each module begins on Friday and lasts until the end of class on the following Thursday.  Students work on "practice WODs" from Friday to Monday, do a "group WOD" on Tuesday, and Amy WOD after that, and an "in class" WOD on Thursday to complete the module. Here's an illustration:

<img class="ui bordered responsive image" src="{{ site.baseurl }}/images/ModuleSchedule.png">

**Skill acquisition, not concept acquisition.** Students are evaluated based upon their ability to complete a task, not on their ability to discuss a concept. For example, a test module would evaluate the ability of a student to define and implement a unit test, not evaluate the ability of the student to describe the difference between a black box test and a white box test. 

**Workout of the day (WOD).**  I have adapted the CrossFit "WOD" to Athletic Software Engineering. In ASE, a "WOD" is a problem that requires the student to exercise one or more skills both correctly (i.e. such that the problem is solved) and efficiently (i.e. within a time limit). There is an upper bound on the time allowed to solve a problem (which typically makes it impossible to "google your way to the answer".) My heuristic for setting the upper bound is to time myself solving the problem, then double this "expert" time to obtain the upper limit for students.  This upper bound is referred to as the "DNF" time (or "Did Not Finish"). This past year, I assigned around 35 WODs each semester, which ranged from 5 minutes to 40 minutes to complete, with most WODs having a DNF time of somewhere between 10 and 20 minutes.

**Practice WODs.**  Each module provides several "practice WODs" to be done as homework between Friday and Tuesday. Practice WODs differ from traditional homework assignments in several ways. First, each practice WOD indicates, in addition to the problem to be solved, the time limit for successful completion of the WOD.  Second, each practice WOD includes a video of me solving the problem, and timing myself while doing so. Third, I typically instruct students to first attempt to solve the problem by themselves without watching my solution video, and time themselves while they do so. If they have not solved the problem by the DNF time, then they should stop at that point and watch my solution video, then try to solve the problem again from scratch, timing their second attempt as well.  If they cannot complete the assignment before the DNF time again, they should review the video and keep attempting to solve the problem until they can do it within the specified time interval. 

Some students admit that they do not follow this procedure, although most learn quickly that this is actually the most efficient way to acquire competency and avoid the dreaded DNF on the "in class WOD" (see below).

**Group WOD.** The Tuesday class is dedicated to one or more "Group WODs".  For each Group WOD, I randomly split the class into groups of two. I then provide a new problem for them to solve using the same skills they (hopefully) developed from the practice WODs.  However, they are now working in a group, and they have to work concurrently (in most cases, I ask that they both complete typing each line of code before either can type the next one.)  Once again, there is a time limit, although the limit is elevated since working concurrently can slow things down, and because I want to encourage them to discuss issues as they arise during the solution process.
 
The Group WOD fulfills several pedagogical goals. First, it provides a self-assessment procedure for students; they can see if their work on the practice WOD has actually prepared them to successfully solve a new problem. Second, it provides an engaging classroom learning environment; rather than working silently alone, they get to work with another student. By the end of the semester, most students have had 1-on-1 time with most other students in the class. Third, it incentivizes students to do the practice WODs, since they know that they will need to demonstrate the skill in class in Tuesday with another student, and this creates social pressure to prepare.  Finally, doing the Group WOD helps the students acquire more competency with the skill itself. 

**Amy WOD.** During academic year 2016-17, my TA's first name was Amy and she held a weekly, voluntary meeting to provide another opportunity to do a timed WOD. Amy WODs are individual and timed, and after the conclusion she goes over the solution. Amy WODs were usually on Tuesday or Wednesday afternoons or evenings, after the students had (hopefully) finished the Practice and Group WODs.

**In class WOD.** The Thursday class period ends the week-long module, and it consists primarily of the "in class WOD", which is yet another individual WOD, but this time it "counts": almost all of the points for the module are based upon the student's ability to solve the problem presented in the In Class WOD both correctly and within the specified time limit.  In class WODs are generally graded on an "all or nothing" basis: if you solve the problem correctly and within the time limit, you get 100% of the available points.  If you don't, you get zero.  

The combination of extensive "training" throughout the week in the form of practice, group, and Amy WODs, followed by a single "performance" to demonstrate the skill, is similar to many athletic (and artistic) disciplines. It is designed to help students learn to take the "training" seriously, just as athletes (and artists) take training seriously, because it is the only way to increase the odds that they will succeed at "game time". It is also intrinsically stressful, and I tell the class that experiencing and acclimating to this "performance" stress is a good thing, as I believe this experience will help them learn to stay calm when they are interviewing for jobs and needing to solve problems at a whiteboard.  
 
## Student evaluation of Athletic Software Engineering
 
Most students report that the weekly in-class WODs are very stressful.  While I theorize that the benefits outweigh the stress, it is important to know what students think.  Every semester, I have students complete a questionnaire about their view of WODs and Athletic Software Engineering. Here are the results from AY 2016-2017.




    
    





  




 











   
 
