---
layout: essay
type: essay
published: false
title: Athletic Software Engineering (2017)
date: 2017-05-30
labels:
  - Athletic Software Engineering
---

For the past four years, I have been refining a pedagogy called "Athletic Software Engineering Education".   This essay presents the motivation for the pedagogy, a brief introduction to how I currently teach it, and the results of student evaluations of the method and my class.

### Motivation

The motivation for athletic software engineering arises from my goals for the students in my course:

  1. *To acquire competency with a minimal technology stack for modern software application development.* In the case of my class, this "minimal" stack includes Javascript, git, GitHub, ESLint, IntelliJ, HTML, CSS, Semantic UI, markdown, mocha, chai, npm, Meteor, MongoDB, and Galaxy.
    
  2. *To confront and solve "design" problems.* Design problems occur at the code level (for example, how to structure code so that it is testable), as well as at the user interface level (for example, how to organize the presentation and manipulation of data so that user needs are satisfied).
  
  3. *To confront and solve "process" problems.* Process problems involve group communication and coordination, and how to define, delegate, and manage tasks such that a group of developers can work together to create a functional application in a limited amount of time. 
  
  4. *Invent an application that solves a "real world" problem for UH students.* For example, students on a meal plan get a certain number of "points" each week for buying food, which do not roll over if unused. To solve this inefficiency, one of my student teams developed an app called "Manoa Dining Delivery", in which students can turn their expiring points into cash by purchasing food at the cafeteria and delivering it to another student on campus. Here is their home page:

<img class="ui responsive image" src="{{ site.baseurl }}/images/manoa_dining_landing.jpg">

These goals build on each other: without competency with a technology stack, it is difficult to successfully address significant coding and user interface design problems.  Significant design problems are needed in order to provide a context for team work with significant process problems. And without the ability to confront and address both design and process problems, it is difficult to create solutions to real world problems (at least within the boundaries of a single semester.)

Furthermore, developing an application to solve a "real world problem" that provides opportunities to experience significant design and process problems is not something that can be done overnight.  I find that students need a minimum of six weeks for the final project in order to achieve something they can be proud of, which leaves only 10 weeks to develop "competency" with the underlying tools and techniques. I developed Athletic Software Engineering to solve the pedagogical problem of developing competency with a significant set of tools and technologies within the context of an undergraduate course. 

### Why "competency" is important

Consider the following development scenario, which is typical during final project development:
 
*A student chooses a development task (Issue 23) from the GitHub Project board, and moves it from "Backlog" to "In Progress". She then creates and publishes a new git branch called "Issue-23" off the project's master branch in which to accomplish the task. The task involves the creation of a new page containing a form in the application. She creates a new page template in Meteor along with a route to that page, several Javascript callback functions to manage form processing, and a responsive layout for the page using HTML, CSS, and Semantic UI. To store the results from the form, she extends a MongoDB collection with new fields, and writes a test using mocha and chai. In the IntelliJ IDEA editor, she notes any ESLint code style errors as they occur and removes them. When the page works correctly, she commits her branch to GitHub, merges the results into the master branch, and moves the task from "In Progress" to "Done".*

Notice that in this (very simple!) development scenario, there are explicit references to a dozen components of a technology stack (GitHub, git, Meteor, Javascript callbacks, HTML, CSS, Semantic UI, MongoDB, mocha, chai, IntelliJ, and ESLint).  There are also implicit references to design problems (What information is being manipulated on that page? Is that the right information to manipulate? Is the chosen page the appropriate place to manipulate that information?) and process problems (Is that the appropriate task for that developer to work on right now? How might that task interact with others being worked on by others in the group? What communication should be occurring to make sure the developers do not implement conflicting code?)

Here is the key insight motivating athletic software engineering: if a student is competent with the technology stack, then _and only then_ is it possible for that student to actively engage with the "design" and "process" issues in development. If a student is not competent with one or more elements of the technology stack, then the focus of attention devolves to obtaining competency. For example, if a student does not understand how to implement a form in Meteor using Semantic UI, then that will be her sole focus of attention until she is competent with that skill; she will not be able to engage with "design" issues around forms when she can't even implement one.  By analogy, consider a guitarist who cannot tune his instrument.  Until he is competent with this skill, he has little hope of progress with chords, inversions, and harmony.
 
One natural question is whether I am introducing an overly complex technology stack.  In fact, I strive to introduce as minimal a technology stack as possible, such that whatever complexity results is intrinsic to the practice of software engineering. Consider that the 12 tools can be organized into the following categories, which I view as fairly central concepts in elementary software engineering:
 
  1. Programming Language (Javascript)
  2. Development Environment (Intellij IDEA)
  3. Project Management (GitHub issues and project boards)
  4. Configuration Management (git branch and merge)
  5. User Interface (HTML, CSS, Semantic UI)
  6. Testing and quality assurance (mocha, chai, ESLint)
  7. Database-backed application framework (Meteor, MongoDB)
  
Over the years, I have taught the class with many different combinations of technologies (Java rather than Javascript, Play rather than Meteor, Bootstrap rather than Semantic UI, Subversion rather than git, Google Project Hosting rather than GitHub, JUnit rather than mocha/chai), but the seven essential software engineering concepts persist, as well as the need to obtain competency with it in order to experience "design" and "process" problems.

### Efficient and effective development of competency

Athletic software engineering is a term I created to describe a set of interrelated teaching practices whose goal is to help students develop "competency" with basic software engineering skills prior to their final project. If they achieve competency with most or all of the skills, then the final project enables them to develop experience with solving design and process problems, and also makes it more likely that they will successfully implement a "minimum viable product".  
 
In a nutshell, athletic software engineering is characterized by the following pedagogical practices:

  * The course consists of a sequence of one week modules.
  
  * Each module is designed to teach a set of skills.  Modules typically build on each other, so that developing competency with this week's skills requires competency with prior week's skills.  Note that sometimes the "lightbulb turns on" for a student after multiple weeks, such that they are suddenly acquire competency with several skills all at once.
  
  * For AY 2016-17, the modules included: Basic Javascript, Object oriented Javascript, Functional Javascript, GitHub and Git, IntelliJ IDEA, ESLint, HTML/CSS, Semantic UI, Meteor (a sequence of four modules), Project Management using GitHub issues and project boards.     
  
  * If the class meets on Tuesdays and Thursdays, then each module starts on Friday and ends at the end of the following Thursday class.
  
  * Between each Friday and Tuesday, the students are responsible for attempting to learn the skills associated with the module.  They do this through assigned readings or videos, as well as through a set of "practice workouts".  A "practice workout" (also called a practice WOD following CrossFit terminology) is a problem that must be solved by utilizing the skills associated with the module. 
   
  * Any "lectures" occur through online videos that the students watch between Friday and Tuesday.  All class time is devoted to actual practice with skills. 
   
  * Most videos are not lectures, however. Instead, for each module, there are typically videos showing the instructor demonstrating how to solve 
  












  




 











   
 
